---
import "../styles/global.css";

interface Props {
	title: string;
	description?: string;
	image?: string | ImageMetadata;
	type?: "website" | "article";
	publishedTime?: Date;
	modifiedTime?: Date;
	author?: string;
	tags?: string[];
}

const {
	title,
	description,
	image,
	type = "website",
	publishedTime,
	modifiedTime,
	author = "Johannes Naylor",
	tags = [],
} = Astro.props;

const canonicalURL = new URL(Astro.url.pathname, Astro.site);
const siteUrl = Astro.site?.toString() || "https://blog.jonaylor.com";

let imageUrl: string;
if (image) {
	if (typeof image === "string") {
		imageUrl = new URL(image, siteUrl).toString();
	} else {
		// It's an ImageMetadata object
		imageUrl = new URL(image.src, siteUrl).toString();
	}
} else {
	imageUrl = `${siteUrl}/og-image.png`;
}
const twitterHandle = "@jonaylor89";
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0" />
    <link rel="icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="canonical" href={canonicalURL} />
    <meta name="generator" content={Astro.generator} />

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=PT+Serif:wght@400;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet" />

    <!-- Primary Meta Tags -->
    <title>{title}</title>
    {description && <meta name="description" content={description} />}
    <meta name="author" content={author} />
    {tags.length > 0 && <meta name="keywords" content={tags.join(', ')} />}

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content={type} />
    <meta property="og:url" content={canonicalURL} />
    <meta property="og:title" content={title} />
    {description && <meta property="og:description" content={description} />}
    <meta property="og:image" content={imageUrl} />
    <meta property="og:site_name" content="Buried Treasure" />
    {type === 'article' && publishedTime && (
      <meta property="article:published_time" content={publishedTime.toISOString()} />
    )}
    {type === 'article' && modifiedTime && (
      <meta property="article:modified_time" content={modifiedTime.toISOString()} />
    )}
    {type === 'article' && author && (
      <meta property="article:author" content={author} />
    )}
    {type === 'article' && tags.map((tag) => (
      <meta property="article:tag" content={tag} />
    ))}

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content={twitterHandle} />
    <meta name="twitter:creator" content={twitterHandle} />
    <meta name="twitter:url" content={canonicalURL} />
    <meta name="twitter:title" content={title} />
    {description && <meta name="twitter:description" content={description} />}
    <meta name="twitter:image" content={imageUrl} />

    <!-- Structured Data (JSON-LD) -->
    {type === 'article' && (
      <script type="application/ld+json" set:html={JSON.stringify({
        '@context': 'https://schema.org',
        '@type': 'BlogPosting',
        headline: title,
        description: description,
        image: imageUrl,
        datePublished: publishedTime?.toISOString(),
        dateModified: modifiedTime?.toISOString() || publishedTime?.toISOString(),
        author: {
          '@type': 'Person',
          name: author,
          url: 'https://jonaylor.com',
        },
        publisher: {
          '@type': 'Person',
          name: author,
        },
        mainEntityOfPage: {
          '@type': 'WebPage',
          '@id': canonicalURL.toString(),
        },
        keywords: tags.join(', '),
      })} />
    )}

    <!-- RSS Feed -->
    <link rel="alternate" type="application/rss+xml" title="Buried Treasure" href="/rss.xml" />

    <!-- Plausible Analytics -->
    <script defer data-domain="blog.jonaylor.com" src="https://plausible.io/js/script.js"></script>
  </head>
  <body class="bg-white dark:bg-gray-900 text-gray-900 dark:text-gray-100">
    <slot />

    <script is:inline>
      // GPU Image Glitch Easter Egg - Performant & Low Profile
      (function() {
        let canvas, gl, program, texture, positionBuffer;
        let currentImage = null;
        let isHovering = false;
        let mousePos = { x: 0.5, y: 0.5 };
        let intensity = 0;
        let animationFrame = null;
        let lastInteraction = Date.now();

        // Vertex shader - simple quad
        const vertexShaderSource = `
          attribute vec2 a_position;
          varying vec2 v_uv;
          void main() {
            v_uv = a_position * 0.5 + 0.5;
            gl_Position = vec4(a_position, 0.0, 1.0);
          }
        `;

        // Fragment shader - glitch effect
        const fragmentShaderSource = `
          precision mediump float;
          uniform sampler2D u_texture;
          uniform vec2 u_mouse;
          uniform float u_time;
          uniform float u_intensity;
          varying vec2 v_uv;

          void main() {
            vec2 uv = v_uv;
            float dist = distance(uv, u_mouse);
            float influence = smoothstep(0.25, 0.0, dist) * u_intensity;

            // RGB channel separation (chromatic aberration)
            float offset = influence * 0.015;
            float r = texture2D(u_texture, uv + vec2(offset, 0.0)).r;
            float g = texture2D(u_texture, uv).g;
            float b = texture2D(u_texture, uv - vec2(offset, 0.0)).b;

            // Scan lines
            float scanline = sin(uv.y * 600.0 + u_time * 15.0) * 0.08 * influence;

            // Block displacement
            float blockY = floor(uv.y * 25.0) / 25.0;
            float blockNoise = fract(sin(blockY * 12.9898 + floor(u_time * 4.0)) * 43758.5453);
            float blockGlitch = step(0.85, blockNoise) * influence;
            vec2 blockOffset = vec2(blockGlitch * 0.08, 0.0);

            vec3 color = vec3(r, g, b);
            if (blockGlitch > 0.0) {
              color = texture2D(u_texture, uv + blockOffset).rgb;
            }
            color += scanline;

            gl_FragColor = vec4(color, 1.0);
          }
        `;

        function initWebGL() {
          if (canvas) return true; // Already initialized - return success!

          canvas = document.createElement('canvas');
          canvas.style.position = 'fixed';
          canvas.style.pointerEvents = 'none';
          canvas.style.zIndex = '9999';
          canvas.style.display = 'none';
          canvas.style.opacity = '0';
          document.body.appendChild(canvas);

          gl = canvas.getContext('webgl', {
            alpha: false,
            antialias: false,
            preserveDrawingBuffer: false
          });

          if (!gl) {
            console.warn('WebGL not supported');
            return false;
          }

          // Compile shaders
          const vertexShader = gl.createShader(gl.VERTEX_SHADER);
          gl.shaderSource(vertexShader, vertexShaderSource);
          gl.compileShader(vertexShader);

          const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
          gl.shaderSource(fragmentShader, fragmentShaderSource);
          gl.compileShader(fragmentShader);

          program = gl.createProgram();
          gl.attachShader(program, vertexShader);
          gl.attachShader(program, fragmentShader);
          gl.linkProgram(program);
          gl.useProgram(program);

          // Setup geometry (fullscreen quad)
          const positions = new Float32Array([-1,-1, 1,-1, -1,1, 1,1]);
          positionBuffer = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

          const positionLocation = gl.getAttribLocation(program, 'a_position');
          gl.enableVertexAttribArray(positionLocation);
          gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

          // Create texture
          texture = gl.createTexture();
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

          return true;
        }

        function positionCanvas(img) {
          const rect = img.getBoundingClientRect();
          canvas.style.left = rect.left + 'px';
          canvas.style.top = rect.top + 'px';
          canvas.width = rect.width;
          canvas.height = rect.height;
          canvas.style.width = rect.width + 'px';
          canvas.style.height = rect.height + 'px';
          gl.viewport(0, 0, canvas.width, canvas.height);
        }

        function loadImageToTexture(img) {
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
        }

        function render() {
          if (!canvas) return;

          const time = Date.now() * 0.001;

          // Ease intensity in/out
          const targetIntensity = isHovering ? 1.0 : 0.0;
          intensity += (targetIntensity - intensity) * 0.15;

          // Sync canvas opacity with effect intensity
          canvas.style.opacity = String(intensity);

          // Clear before drawing
          gl.clearColor(0, 0, 0, 1);
          gl.clear(gl.COLOR_BUFFER_BIT);

          gl.useProgram(program);
          gl.uniform1i(gl.getUniformLocation(program, 'u_texture'), 0);
          gl.uniform2f(gl.getUniformLocation(program, 'u_mouse'), mousePos.x, mousePos.y);
          gl.uniform1f(gl.getUniformLocation(program, 'u_time'), time);
          gl.uniform1f(gl.getUniformLocation(program, 'u_intensity'), intensity);

          gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

          // Continue animating while fading out
          if (isHovering || intensity > 0.01) {
            animationFrame = requestAnimationFrame(render);
          } else {
            // Animation completely finished
            stopRendering();
          }
        }

        function startRendering(img) {
          if (!initWebGL()) return;

          // Cancel any existing animation to prevent race conditions
          if (animationFrame) {
            cancelAnimationFrame(animationFrame);
            animationFrame = null;
          }

          currentImage = img;
          positionCanvas(img);
          loadImageToTexture(img);

          // Reset intensity for fade-in effect
          intensity = 0;

          // Show canvas - opacity will be controlled by render loop
          canvas.style.display = 'block';

          // Always start a fresh render loop
          animationFrame = requestAnimationFrame(render);
        }

        function stopRendering() {
          if (animationFrame) {
            cancelAnimationFrame(animationFrame);
            animationFrame = null;
          }
          if (canvas) {
            canvas.style.display = 'none';
            canvas.style.opacity = '0';
          }
          currentImage = null;
          intensity = 0;
        }

        // Cleanup after inactivity
        function checkInactivity() {
          if (Date.now() - lastInteraction > 5000 && !isHovering && canvas) {
            // Remove canvas after 5s of inactivity
            const opacity = parseFloat(canvas.style.opacity);
            if (opacity === 0 && canvas.style.display === 'none') {
              canvas.remove();
              canvas = null;
              gl = null;
            }
          }
        }
        setInterval(checkInactivity, 1000);

        // Event handlers
        function handleMouseMove(e) {
          if (!isHovering || !currentImage) return;

          const rect = currentImage.getBoundingClientRect();
          mousePos.x = (e.clientX - rect.left) / rect.width;
          mousePos.y = (e.clientY - rect.top) / rect.height;
          lastInteraction = Date.now();
        }

        function handleMouseEnter(e) {
          const img = e.target;
          isHovering = true;
          startRendering(img);
          handleMouseMove(e);
        }

        function handleMouseLeave() {
          isHovering = false;
          lastInteraction = Date.now();
        }

        // Attach listeners to all images
        function attachListeners() {
          const images = document.querySelectorAll('img');
          images.forEach(img => {
            img.style.cursor = 'crosshair';
            img.addEventListener('mouseenter', handleMouseEnter);
            img.addEventListener('mouseleave', handleMouseLeave);
            img.addEventListener('mousemove', handleMouseMove);
          });
        }

        // Initialize on load
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', attachListeners);
        } else {
          attachListeners();
        }

        // Re-attach for dynamically loaded images
        const observer = new MutationObserver(() => attachListeners());
        observer.observe(document.body, { childList: true, subtree: true });
      })();
    </script>
  </body>
</html>
